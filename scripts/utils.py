import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import copy
import re


def get_colors():
    colors = ['rosybrown', 'goldenrod','mediumturquoise', 'darkslateblue',
          'darkred', 'darkkhaki', 'teal', 'mediumorchid',
          'linen', 'lightgreen', 'slategray', 'lightpink',
          'indianred', 'gold', 'lightcyan', 'blueviolet',
          'coral', 'yellow', 'powderblue', 'fuchsia'
          ]
    print(f'number of colors defined: {len(colors)}')
    return colors

# Print legend to have a correspondance between numbers and colors
def legend(n):
  colors = get_colors()
  for i in range(n):
    print(f'{i}: {colors[i]}')

def extract_integer(s):
    match = re.search(r'\d+', s)
    if match:
        return int(match.group())
    else:
        return None


# Custom function to compute the radius of cluster obtained using kmeans
# It simply return the average distance betweena all points and the centroid

def compute_radius(points, centroid):
  if points.size == 0:  # Check if points array is empty
    return 0  # Return 0 as radius for empty cluster
  distances = np.linalg.norm(points - centroid, axis=1)
  radius = np.average(distances)
  return radius

# Function to find the first missing positive number
# It is used to assign the smaller ID to new appearring cluster
# Useful when a cluster disappears and then a new one appears: we can give to the new one the ID of the old one
# Avoid to go out of colors

def find_missing_positive(nums):
    n = len(nums)
    # Mark visited numbers by negating them
    for i in range(n):
        num = abs(nums[i])
        if 1 <= num <= n:
            nums[num - 1] = -abs(nums[num - 1])
    # Find the first positive number
    for i in range(n):
        if nums[i] > 0:
            return i + 1
    return n + 1

# Given an element and a list of lists, it returns true if the element is in at least one of the sublists
# It is used in mapping function to check if the old cluster is survived in at least one of the current clusters

def is_in_any_sublist(element, list_of_lists):
  for sublist in list_of_lists:
    if element in sublist:
      return True
  return False

# Given an element and a list of lists, it returns true if the element is in at least two of the sublists
# It is used in mapping fucntion to check if an old cluster is splitted in 2 or more clusters

def appears_in_at_least_two_sublists(element, list_of_lists):
    count = 0
    for sublist in list_of_lists:
        if element in sublist:
            count += 1
            if count >= 2:
                return True
    return False


# given a list of dictionaries (eg macroclusters) it keeps only the first occurances and remove the duplicates
# It is used when a clusters survives in 2 or more clusters (ie splitted)
# Update only the first one and the others are considered generated by the split (assigning the first available color)

def keep_first_occurrences(list_of_dicts):
    seen_dicts = set()
    unique_dicts = []
    for d in list_of_dicts:
        # Create a deep copy of the dictionary to avoid modifying the original
        d_copy = copy.deepcopy(d)
        temp_element = {'radius': d_copy['radius'], 'center': d_copy['center']}
        # Convert dictionary to a hashable tuple, sorting keys for consistency, after converting lists to tuples
        tuple_d = tuple(sorted([(k, tuple(v) if isinstance(v, list) else v) for k, v in temp_element.items()]))
        if tuple_d not in seen_dicts:
            seen_dicts.add(tuple_d)
            unique_dicts.append(d)  # Append the original dictionary
    return unique_dicts


# Given two macroclusters (ideally the same one that survived ie m1 survived as m2) it returns the internal transitions
# namely the distance between the centers and ratio between radii

def internal_transition(m1,m2):
  c1 = m1['center']
  c2 = m2['center']
  r1 = m1['radius']
  r2 = m2['radius']

  dist = np.linalg.norm(np.array(c1) - np.array(c2))
  radius_ratio = r1/r2

  return dist, radius_ratio


# Function to get the fig of clustered image

def get_snapshot_image(snapshot, colors, x_limits=(-5, 20), y_limits=(-5, 20)):

  centers = [d['center'] for d in snapshot.macroclusters]
  radii = [d['radius'] for d in snapshot.macroclusters]

  labels = [[] for _ in range(snapshot.k)]

  fig, ax = plt.subplots()
  for i in range(snapshot.microclusters.shape[0]):
    prediction = snapshot.model.predict_one({0: snapshot.microclusters[i, 0], 1: snapshot.microclusters[i, 1]})

    closest_centroid = snapshot.model.macroclusters[prediction]
    closest_centroid_center = closest_centroid['center']
    closest_centroid_radius = closest_centroid['radius']

    color = 'k'

    for element in snapshot.macroclusters:
      if element['center'] == closest_centroid_center:
        color = colors[element['id']]
        break
    plt.scatter(snapshot.microclusters[i, 0], snapshot.microclusters[i, 1], alpha=0.5, color=color)

  plt.scatter(np.array(centers)[:, 0], np.array(centers)[:, 1], alpha=1, color='k', label='centers')
  for i in range(len(centers)):
    center = centers[i]
    radius = radii[i]
    circle = plt.Circle((centers[i]), radii[i], color='black', fill=False)
    plt.scatter(center[0], center[1], alpha=1, color='black')
    ax.add_patch(circle)

  plt.legend()
  plt.title(f'Snapshot at {snapshot.timestamp}')
  plt.axis('equal')
  plt.xlim(x_limits)
  plt.ylim(y_limits)
  plt.figure(figsize=(10, 10))

  return fig


def circular_trajectory(center_x, center_y, radius, num_points, start_angle=0, end_angle=2*np.pi):
  """Generates a circular trajectory centered at (center_x, center_y).

  Args:
    center_x: x-coordinate of the center.
    center_y: y-coordinate of the center.
    radius: Radius of the circle.
    num_points: Number of points in the trajectory.
    start_angle: Starting angle in radians (default: 0).
    end_angle: Ending angle in radians (default: 2*pi).

  Returns:
    A list of tuples, where each tuple represents an (x, y) coordinate.
  """

  theta = np.linspace(start_angle, end_angle, num_points)
  x = center_x + radius * np.cos(theta)
  y = center_y + radius * np.sin(theta)

  return list(zip(x, y))


def linear_trajectory(start_point, end_point, num_points):
  """Generates a linear trajectory between two points.

  Args:
    start_point: A tuple representing the starting point (x1, y1).
    end_point: A tuple representing the ending point (x2, y2).
    num_points: The number of points in the trajectory.

  Returns:
    A list of tuples, where each tuple represents an (x, y) coordinate on the trajectory.
  """

  x1, y1 = start_point
  x2, y2 = end_point

  x = np.linspace(x1, x2, num_points)
  y = np.linspace(y1, y2, num_points)

  return list(zip(x, y))


def plot_data(data):
  # Assuming your data has two features
  x = data[:, 0]
  y = data[:, 1]

  plt.scatter(x, y, alpha=0.1)

  plt.axis('equal')
  plt.xlim(-50, 50)
  plt.ylim(-50, 50)
  plt.figure(figsize=(10, 10))
  plt.show()

def anim_data(data, title=''):
  # Assuming your data has two features
  x = data[:, 0]
  y = data[:, 1]

  # Create a figure and axis
  fig, ax = plt.subplots()
  ax.set_xlim(-50, 50)
  ax.set_ylim(-50, 50)
  ax.axis('equal')

  # Initialize an empty scatter plot
  scatter = ax.scatter([], [], s=10)

  def update_plot(i):
    scatter.set_offsets(np.vstack((scatter.get_offsets().data, [[x[i], y[i]]])))

  # Create the animation
  ani = animation.FuncAnimation(fig, update_plot, frames=len(x), interval=10)
  ani.save(f'{title}_animation.mp4')
  print('Animation saved!')