import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import copy
import re
import os


def get_colors():
    colors = ['rosybrown', 'goldenrod','mediumturquoise', 'darkslateblue',
          'darkred', 'darkkhaki', 'teal', 'mediumorchid',
          'linen', 'lightgreen', 'slategray', 'lightpink',
          'indianred', 'gold', 'lightcyan', 'blueviolet',
          'coral', 'yellow', 'powderblue', 'fuchsia'
          ]
    print(f'number of colors defined: {len(colors)}')
    return colors

# Print legend to have a correspondance between numbers and colors
def legend(n):
  colors = get_colors()
  for i in range(n):
    print(f'{i}: {colors[i]}')

def extract_integer(s):
    match = re.search(r'\d+', s)
    if match:
        return int(match.group())
    else:
        return None


# Custom function to compute the radius of cluster obtained using kmeans
# It simply return the average distance betweena all points and the centroid

def compute_radius(points, centroid):
  if points.size == 0:  # Check if points array is empty
    return 0  # Return 0 as radius for empty cluster
  distances = np.linalg.norm(points - centroid, axis=1)
  radius = np.average(distances)
  return radius

# Function to find the first missing positive number
# It is used to assign the smaller ID to new appearring cluster
# Useful when a cluster disappears and then a new one appears: we can give to the new one the ID of the old one
# Avoid to go out of colors

def find_missing_positive(nums):
    n = len(nums)
    # Mark visited numbers by negating them
    for i in range(n):
        num = abs(nums[i])
        if 1 <= num <= n:
            nums[num - 1] = -abs(nums[num - 1])
    # Find the first positive number
    for i in range(n):
        if nums[i] > 0:
            return i + 1
    return n + 1

# Given an element and a list of lists, it returns true if the element is in at least one of the sublists
# It is used in mapping function to check if the old cluster is survived in at least one of the current clusters

def is_in_any_sublist(element, list_of_lists):
  for sublist in list_of_lists:
    if element in sublist:
      return True
  return False

def count_occurrences_in_sublists(element, list_of_lists):
  count = 0
  for sublist in list_of_lists:
    count += sublist.count(element)
  return count

# Given an element and a list of lists, it returns true if the element is in at least two of the sublists
# It is used in mapping fucntion to check if an old cluster is splitted in 2 or more clusters

def appears_in_at_least_two_sublists(element, list_of_lists):
    count = 0
    for sublist in list_of_lists:
        if element in sublist:
            count += 1
            if count >= 2:
                return True
    return False


# given a list of dictionaries (eg macroclusters) it keeps only the first occurances and remove the duplicates
# It is used when a clusters survives in 2 or more clusters (ie splitted)
# Update only the first one and the others are considered generated by the split (assigning the first available color)

def keep_first_occurrences(clusters):
    seen = set()
    result = []
    for obj in clusters:
      if obj not in seen:
        seen.add(obj)
        result.append(obj)
    return result


# Given two macroclusters (ideally the same one that survived ie m1 survived as m2) it returns the internal transitions
# namely the distance between the centers and ratio between radii

def internal_transition(m1,m2):
  c1 = m1.get_center()
  c2 = m2.get_center()
  r1 = m1.get_radius()
  r2 = m2.get_radius()

  dist = np.linalg.norm(np.array(c1) - np.array(c2))
  radius_ratio = r1/r2

  return dist, radius_ratio


# Function to get the fig of clustered image

def get_snapshot_image(snapshot, colors, x_limits=(-5, 20), y_limits=(-5, 20)):

  centers = [d.get_center() for d in snapshot.macroclusters]
  radii = [d.get_radius() for d in snapshot.macroclusters]


  labels = [[] for _ in range(snapshot.k)]

  fig, ax = plt.subplots()
  for i in range(snapshot.microclusters.shape[0]):
    prediction = snapshot.model.predict_one({0: snapshot.microclusters[i, 0], 1: snapshot.microclusters[i, 1]})

    closest_centroid = snapshot.model.macroclusters[prediction]
    closest_centroid_center = closest_centroid['center']
    closest_centroid_radius = closest_centroid['radius']

    color = 'k'

    for element in snapshot.macroclusters:
      if element.get_center() == closest_centroid_center:
        color = colors[element.get_id()]
        break
    plt.scatter(snapshot.microclusters[i, 0], snapshot.microclusters[i, 1], alpha=0.5, color=color)

  plt.scatter(np.array(centers)[:, 0], np.array(centers)[:, 1], alpha=1, color='k', label='centers')
  for i in range(len(centers)):
    center = centers[i]
    radius = radii[i]
    circle = plt.Circle(center, radius, color='black', fill=False)
    plt.scatter(center[0], center[1], alpha=1, color='black')
    ax.add_patch(circle)

  plt.legend()
  plt.title(f'Snapshot at {snapshot.timestamp}')
  #plt.axis('equal')
  plt.xlim(x_limits)
  plt.ylim(y_limits)
  plt.figure(figsize=(10, 10))

  return fig


def circular_trajectory(center_x, center_y, radius, num_points, start_angle=0, end_angle=2*np.pi):
  """Generates a circular trajectory centered at (center_x, center_y).

  Args:
    center_x: x-coordinate of the center.
    center_y: y-coordinate of the center.
    radius: Radius of the circle.
    num_points: Number of points in the trajectory.
    start_angle: Starting angle in radians (default: 0).
    end_angle: Ending angle in radians (default: 2*pi).

  Returns:
    A list of tuples, where each tuple represents an (x, y) coordinate.
  """

  theta = np.linspace(start_angle, end_angle, num_points)
  x = center_x + radius * np.cos(theta)
  y = center_y + radius * np.sin(theta)

  return list(zip(x, y))


def linear_trajectory(start_point, end_point, num_points):
  """Generates a linear trajectory between two points.

  Args:
    start_point: A tuple representing the starting point (x1, y1).
    end_point: A tuple representing the ending point (x2, y2).
    num_points: The number of points in the trajectory.

  Returns:
    A list of tuples, where each tuple represents an (x, y) coordinate on the trajectory.
  """

  x1, y1 = start_point
  x2, y2 = end_point

  x = np.linspace(x1, x2, num_points)
  y = np.linspace(y1, y2, num_points)

  return list(zip(x, y))


def plot_data(data):
  # Assuming your data has two features
  x = data[:, 0]
  y = data[:, 1]

  plt.scatter(x, y, alpha=0.1)

  plt.axis('equal')
  plt.xlim(-50, 50)
  plt.ylim(-50, 50)
  plt.figure(figsize=(10, 10))
  plt.show()

def get_data(means, std_devs, n_samples):
  data = []
  covs = [np.diag(std_dev**2) for std_dev in std_devs]
  # Derive n_samples for each distribution
  for mean, cov in zip(means, covs):
      data.append(np.random.multivariate_normal(mean, cov, n_samples))
  data = np.array(data)
  data = data.reshape(data.shape[0] * data.shape[1], data.shape[2])
  np.random.shuffle(data)
  return data

def anim_data(data, title=''):
  # Assuming your data has two features
  x = data[:, 0]
  y = data[:, 1]

  # Create a figure and axis
  fig, ax = plt.subplots()
  ax.set_xlim(-50, 50)
  ax.set_ylim(-50, 50)
  ax.axis('equal')

  # Initialize an empty scatter plot
  scatter = ax.scatter([], [], s=10)

  def update_plot(i):
    scatter.set_offsets(np.vstack((scatter.get_offsets().data, [[x[i], y[i]]])))

  # Create the animation
  ani = animation.FuncAnimation(fig, update_plot, frames=len(x), interval=10)
  ani.save(f'{title}_animation.mp4')
  print('Animation saved!')

def clean_directory(directory_path):
  try:
    for filename in os.listdir(directory_path):
      file_path = os.path.join(directory_path, filename)
      if os.path.isfile(file_path):
        os.remove(file_path)
      elif os.path.isdir(file_path):
        clean_directory(file_path)
    os.rmdir(directory_path)
    print(f"Directory '{directory_path}' and its contents removed successfully.")
  except OSError as e:
    print(f"Error removing directory '{directory_path}': {e}")


def sublist_present(sublist, list_of_sublists):
  """
  Checks if a sublist is present in a list of sublists, regardless of order.

  Args:
    sublist: The sublist to check.
    list_of_sublists: The list of sublists to search in.

  Returns:
    True if the sublist is found in any of the sublists in the list_of_sublists, 
    False otherwise.
  """
  for sublist_in_list in list_of_sublists:
    if set(sublist) == set(sublist_in_list):
      return True
  return False

def find_closest_cluster(new_cluster, macroclusters):
  """
  Finds the closest cluster to a given centroid.

  Args:
    centroid: The centroid to find the closest cluster to.
    macroclusters: A list of macroclusters.

  Returns:
    The the closest cluster in the list of macroclusters.
  """
  if len(macroclusters) != 0:
    distances = [np.linalg.norm(np.array(new_cluster.get_center()) - np.array(cluster.get_center())) for cluster in macroclusters]
    return macroclusters[np.argmin(distances)]
  else:
     print("List length = 0 ---> Returning 0")
     return 0